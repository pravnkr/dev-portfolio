{"status":"ok","feed":{"url":"https://medium.com/feed/@@praveenkumarlsipl","title":"Stories by Praveen kumar on Medium","link":"https://medium.com/@praveenkumarlsipl?source=rss-5f4439f08177------2","author":"","description":"Stories by Praveen kumar on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*HWsGCJESbltW2ryOVMic_A.jpeg"},"items":[{"title":"Implementing a Map Strategy Pattern With Angular 13+","pubDate":"2022-05-29 17:36:40","link":"https://medium.com/@praveenkumarlsipl/implementing-a-map-strategy-pattern-with-angular-13-bd06065bad50?source=rss-5f4439f08177------2","guid":"https://medium.com/p/bd06065bad50","author":"Praveen kumar","thumbnail":"https://cdn-images-1.medium.com/max/640/1*dB7_jvLcEdEyj-D6NJZREg.png","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/1*dB7_jvLcEdEyj-D6NJZREg.png\"></figure><h4>Problem</h4>\n<p>Let\u2019s suppose we were having a code snippet with a structure like if {\u2026} else if (\u2026) else if (\u2026)\u00a0\u2026 else {\u2026}. It just does not looks neat and introduces a code smell most of the time. You can create an analogy of the same structure with a switch statement as\u00a0well.</p>\n<p>However, This is not always the problem especially when the no of else if constructs are limited and the scope for the new else-if snippet is minimal otherwise you will find yourself breaking the Open/Closed Principle from the <a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID</a> which is again another reason for thinking about the refactoring the code. Having so many else if construct should also mean you should rethink the design, especially keeping in mind the Single Responsibility(Again from the SOLID) based\u00a0design.</p>\n<p>We can always solve these types of problems with a map strategy\u00a0pattern.</p>\n<h3>Real-World Examples</h3>\n<h4>Payment methods</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8O571tupPxNjw4p5FdSyxQ.jpeg\"></figure><p>The Application can have multiple payment methods and thus different strategies for them, for example, Net Banking, Card, UPI,\u00a0etc.</p>\n<h4>Exception Translators</h4>\n<p>Let\u2019s suppose we have a REST-based service returning different response schema based on different HTTP status codes. Here again, we can have a different strategy for these different codes, and further, we can easily hook in the different UI screens based on these different strategies.</p>\n<h3>What is the Map inside the Map Strategy\u00a0pattern?</h3>\n<p>Well let\u2019s take the <em>2nd </em>example, We need some way to resolve the strategy based on the data we have. In this case, we have an HTTP status code and the Response schema. So for a resolution purpose, we can have something like:</p>\n<pre>Map&lt;HTTP_STATUS_CODES, STRATEGY&gt;</pre>\n<p>Let\u2019s say we have some abstraction for resolution, call it <em>ExceptionTranslator</em>. Now we can easily use the HTTP code as the key to get the strategy from the map and further execute the custom logic. This will look something like\u00a0this:</p>\n<pre><em>ExceptionTranslator.strategyMap.get(HttpCode) -&gt; Strategy</em></pre>\n<p>Different languages and frameworks might have different ways to build that map. Most of them use another design pattern <a href=\"https://en.wikipedia.org/wiki/Dependency_injection\">Dependency Injection</a> for this purpose. Next, We will see how can we apply this technique in\u00a0angular.</p>\n<h3>Angular Complete\u00a0Example</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/250/1*nbJ41jD1-r2Oe6FsLjKaOg.png\"></figure><p>For a complete codebase for this example please refer to this Github repository: <a href=\"https://github.com/pravnkr/angular-strategy-pattern\">https://github.com/pravnkr/angular-strategy-pattern</a>.</p>\n<p>For brevity, we are designing a very simple different strategy-based message translator where we are rendering the different translated messages based on the different message\u00a0keys.</p>\n<p>This will be the abstraction for our message translator:</p>\n<pre>import { InjectionToken } from '@angular/core';</pre>\n<pre>export <em>interface</em> MessageTranslator {</pre>\n<pre>    getKey(): <em>string</em>;</pre>\n<pre>    translate(): <em>string</em>;</pre>\n<pre>}</pre>\n<pre>export <em>const</em> MESSAGE_TRANSLATORS = new InjectionToken&lt;MessageTranslator&gt;('MessageTranslator');</pre>\n<p>We will use <strong><em>MESSAGE_TRANSLATORS </em></strong>as an injection token for injecting the list of different <em>MessageTranslator</em> implementations.</p>\n<p>We will be having the following 2 implementations of the <em>MessageTranslator</em>:</p>\n<p><strong><em>IncorrectUserNameOrPasswordMessageTranslator</em></strong></p>\n<pre>import { Injectable } from '@angular/core';<br>import { MessageTranslator } from './message-translator';</pre>\n<pre>@Injectable({<br>    providedIn: 'root',<br>})</pre>\n<pre>export <em>class</em> IncorrectUserNameOrPasswordMessageTranslator implements MessageTranslator {<br>    getKey() {<br>        return 'IncorrectUserNameOrPasswordMessage';<br>    }</pre>\n<pre>    translate(): <em>string</em> {<br>        return 'Wrong Username or Password - Please try again or contact Customer Support Team.';<br>    }<br>}</pre>\n<p><strong><em>SessionExpiredMessageTranslator</em></strong></p>\n<pre>import { Injectable } from '@angular/core';<br>import { MessageTranslator } from './message-translator';</pre>\n<pre>@Injectable({<br>    providedIn: 'root',<br>})</pre>\n<pre>export <em>class</em> SessionExpiredMessageTranslator implements MessageTranslator {<br>    getKey() {<br>        return 'SessionExpiredMessage';<br>    }</pre>\n<pre>    translate(): <em>string</em> {<br>        return 'The session has expired, to continue please relogin.';<br>    }<br>}</pre>\n<p>Next, we will have a <strong><em>MessageTranslatorMap </em></strong>will be our strategy map and will be <em>Map&lt;String, MessageTranslator</em><strong><em>&gt;. </em></strong>We had kept this map as a service so that we can easily inject it at places where\u00a0needed.</p>\n<pre>import { Inject, Injectable } from '@angular/core';<br>import { MessageTranslator, MESSAGE_TRANSLATORS } from './message-translator';</pre>\n<pre>@Injectable({<br>    providedIn: 'root',<br>})<br>export <em>class</em> MessageTranslatorMap {<br>    private map = new <em>Map</em>&lt;<em>string</em>, <em>string</em>&gt;();</pre>\n<pre><em>    constructor</em>(@Inject(MESSAGE_TRANSLATORS) <em>translators</em>: MessageTranslator[]) {<br>        for (<em>let</em> translator of <em>translators</em>) {<br>            this.map.set(translator.getKey(), translator.translate());<br>        }<br>    }</pre>\n<pre>    getMap(): <em>ReadonlyMap</em>&lt;<em>string</em>, <em>string</em>&gt; {<br>        return this.map;<br>    }<br>}</pre>\n<p>We used the following simulation for a message producer, which produces a message key every second randomly. In our case we had just kept 2 possible options <em>SessionExpiredMessage and IncorrectUserNameOrPasswordMessage</em> for brevity, however, in real scenarios, we can have multiple message keys based on the\u00a0domain.</p>\n<p><strong><em>MessageProducer</em></strong></p>\n<pre>import { interval, map, tap } from \"rxjs\";</pre>\n<pre><em>const</em> getRandomInt = (<em>min</em>: <em>number</em>, <em>max</em>: <em>number</em>) <em>=&gt;</em> {<br><em>min</em> = Math.ceil(<em>min</em>);<br><em>max</em> = Math.floor(<em>max</em>);<br>    return Math.floor(Math.random() * (<em>max</em> - <em>min</em>) + <em>min</em>); //The<br>maximum is exclusive and the minimum is inclusive<br>}</pre>\n<pre><em>const</em> messages = ['IncorrectUserNameOrPasswordMessage', 'SessionExpiredMessage'];</pre>\n<pre>/**<br>* Simple simulation for message producer transmitting message every second.<br>*/<br>export <em>const</em> produceMessage = () <em>=&gt;</em> {<br>    return interval(1000)<br>        .pipe(map(() <em>=&gt;</em> messages[getRandomInt(0, messages.length)]));<br>}</pre>\n<p>We will have to declare the providers for the message translators inside the module <strong><em>app.module.ts</em></strong></p>\n<pre>import { NgModule } from '@angular/core';<br>import { BrowserModule } from '@angular/platform-browser';<br>import { AppComponent } from './app.component';<br>import { IncorrectUserNameOrPasswordMessageTranslator } from './message-translators/incorrect-user-name-message-translator.service';<br>import { MESSAGE_TRANSLATORS } from './message-translators/message-translator';<br>import { SessionExpiredMessageTranslator } from './message-translators/session-expired-message-translator.service';</pre>\n<pre>@NgModule({<br>    declarations: [<br>        AppComponent<br>    ],<br>    imports: [<br>        BrowserModule<br>    ],<br>    providers: [<br>        { provide: MESSAGE_TRANSLATORS, useClass: IncorrectUserNameOrPasswordMessageTranslator, multi: true },<br>        { provide: MESSAGE_TRANSLATORS, useClass: SessionExpiredMessageTranslator, multi: true },<br>    ],<br>    bootstrap: [AppComponent]<br>})<br>export <em>class</em> AppModule { }</pre>\n<p>Finally here is a very simple template for rendering the message key and translated message: <strong><em>app.component.html</em></strong></p>\n<pre>&lt;div class=\"container\"&gt;<br>    &lt;h1&gt;Strategy Demo&lt;/h1&gt;<br>    &lt;div class=\"row\"&gt;<br>        &lt;div class=\"col-4\"&gt;<br>            Message Key<br>        &lt;/div&gt;<br>        &lt;div class=\"col-8\"&gt;<br>            &lt;p #key &gt;{{ messageKeyStream$ | async }}&lt;/p&gt;<br>        &lt;/div&gt;<br>        &lt;div class=\"col-4\"&gt;<br>            Translated Message<br>        &lt;/div&gt;<br>        &lt;div class=\"col-8\"&gt;<br>            {{ getTranslatedMessageFor(key.innerText) }}<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/div&gt;</pre>\n<p><strong><em>app.component.ts</em></strong></p>\n<pre>import { Component } from '@angular/core';<br>import { Observable, tap } from 'rxjs';<br>import { MessageTranslatorMap } from './message-translators/message-translator-map.service';<br>import { produceMessage } from './mock/message-producer.mock';</pre>\n<pre>@Component({<br>    selector: 'app-root',<br>    templateUrl: './app.component.html',<br>    styleUrls: ['./app.component.css']<br>})<br>export <em>class</em> AppComponent {<br>    messageKeyStream$: Observable&lt;<em>string</em>&gt;;</pre>\n<pre><em>    constructor</em>(private <em>messageTranslator</em>: MessageTranslatorMap) {<br>        /**<br>         * return a stream where each emitted item will serve as a key for the strategy.<br>         */<br>        this.messageKeyStream$ = produceMessage();<br>    }</pre>\n<pre>    getTranslatedMessageFor(<em>key</em>: <em>string</em>) {<br>        return this.messageTranslator.getMap().get(<em>key</em>);<br>    }<br>}</pre>\n<p>Hope you have liked the article and will find it useful for your projects.</p>\n<p>Connect with me on <a href=\"https://www.linkedin.com/in/praveen-kumar-788429192/\">LinkedIn</a>.</p>\n<p>Check out my developer <a href=\"https://pravnkr.github.io/dev-portfolio/\">Portfolio</a>.</p>\n<p>Go and check out my work on\u00a0<a href=\"https://github.com/pravnkr\">Github</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bd06065bad50\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/1*dB7_jvLcEdEyj-D6NJZREg.png\"></figure><h4>Problem</h4>\n<p>Let\u2019s suppose we were having a code snippet with a structure like if {\u2026} else if (\u2026) else if (\u2026)\u00a0\u2026 else {\u2026}. It just does not looks neat and introduces a code smell most of the time. You can create an analogy of the same structure with a switch statement as\u00a0well.</p>\n<p>However, This is not always the problem especially when the no of else if constructs are limited and the scope for the new else-if snippet is minimal otherwise you will find yourself breaking the Open/Closed Principle from the <a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID</a> which is again another reason for thinking about the refactoring the code. Having so many else if construct should also mean you should rethink the design, especially keeping in mind the Single Responsibility(Again from the SOLID) based\u00a0design.</p>\n<p>We can always solve these types of problems with a map strategy\u00a0pattern.</p>\n<h3>Real-World Examples</h3>\n<h4>Payment methods</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8O571tupPxNjw4p5FdSyxQ.jpeg\"></figure><p>The Application can have multiple payment methods and thus different strategies for them, for example, Net Banking, Card, UPI,\u00a0etc.</p>\n<h4>Exception Translators</h4>\n<p>Let\u2019s suppose we have a REST-based service returning different response schema based on different HTTP status codes. Here again, we can have a different strategy for these different codes, and further, we can easily hook in the different UI screens based on these different strategies.</p>\n<h3>What is the Map inside the Map Strategy\u00a0pattern?</h3>\n<p>Well let\u2019s take the <em>2nd </em>example, We need some way to resolve the strategy based on the data we have. In this case, we have an HTTP status code and the Response schema. So for a resolution purpose, we can have something like:</p>\n<pre>Map&lt;HTTP_STATUS_CODES, STRATEGY&gt;</pre>\n<p>Let\u2019s say we have some abstraction for resolution, call it <em>ExceptionTranslator</em>. Now we can easily use the HTTP code as the key to get the strategy from the map and further execute the custom logic. This will look something like\u00a0this:</p>\n<pre><em>ExceptionTranslator.strategyMap.get(HttpCode) -&gt; Strategy</em></pre>\n<p>Different languages and frameworks might have different ways to build that map. Most of them use another design pattern <a href=\"https://en.wikipedia.org/wiki/Dependency_injection\">Dependency Injection</a> for this purpose. Next, We will see how can we apply this technique in\u00a0angular.</p>\n<h3>Angular Complete\u00a0Example</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/250/1*nbJ41jD1-r2Oe6FsLjKaOg.png\"></figure><p>For a complete codebase for this example please refer to this Github repository: <a href=\"https://github.com/pravnkr/angular-strategy-pattern\">https://github.com/pravnkr/angular-strategy-pattern</a>.</p>\n<p>For brevity, we are designing a very simple different strategy-based message translator where we are rendering the different translated messages based on the different message\u00a0keys.</p>\n<p>This will be the abstraction for our message translator:</p>\n<pre>import { InjectionToken } from '@angular/core';</pre>\n<pre>export <em>interface</em> MessageTranslator {</pre>\n<pre>    getKey(): <em>string</em>;</pre>\n<pre>    translate(): <em>string</em>;</pre>\n<pre>}</pre>\n<pre>export <em>const</em> MESSAGE_TRANSLATORS = new InjectionToken&lt;MessageTranslator&gt;('MessageTranslator');</pre>\n<p>We will use <strong><em>MESSAGE_TRANSLATORS </em></strong>as an injection token for injecting the list of different <em>MessageTranslator</em> implementations.</p>\n<p>We will be having the following 2 implementations of the <em>MessageTranslator</em>:</p>\n<p><strong><em>IncorrectUserNameOrPasswordMessageTranslator</em></strong></p>\n<pre>import { Injectable } from '@angular/core';<br>import { MessageTranslator } from './message-translator';</pre>\n<pre>@Injectable({<br>    providedIn: 'root',<br>})</pre>\n<pre>export <em>class</em> IncorrectUserNameOrPasswordMessageTranslator implements MessageTranslator {<br>    getKey() {<br>        return 'IncorrectUserNameOrPasswordMessage';<br>    }</pre>\n<pre>    translate(): <em>string</em> {<br>        return 'Wrong Username or Password - Please try again or contact Customer Support Team.';<br>    }<br>}</pre>\n<p><strong><em>SessionExpiredMessageTranslator</em></strong></p>\n<pre>import { Injectable } from '@angular/core';<br>import { MessageTranslator } from './message-translator';</pre>\n<pre>@Injectable({<br>    providedIn: 'root',<br>})</pre>\n<pre>export <em>class</em> SessionExpiredMessageTranslator implements MessageTranslator {<br>    getKey() {<br>        return 'SessionExpiredMessage';<br>    }</pre>\n<pre>    translate(): <em>string</em> {<br>        return 'The session has expired, to continue please relogin.';<br>    }<br>}</pre>\n<p>Next, we will have a <strong><em>MessageTranslatorMap </em></strong>will be our strategy map and will be <em>Map&lt;String, MessageTranslator</em><strong><em>&gt;. </em></strong>We had kept this map as a service so that we can easily inject it at places where\u00a0needed.</p>\n<pre>import { Inject, Injectable } from '@angular/core';<br>import { MessageTranslator, MESSAGE_TRANSLATORS } from './message-translator';</pre>\n<pre>@Injectable({<br>    providedIn: 'root',<br>})<br>export <em>class</em> MessageTranslatorMap {<br>    private map = new <em>Map</em>&lt;<em>string</em>, <em>string</em>&gt;();</pre>\n<pre><em>    constructor</em>(@Inject(MESSAGE_TRANSLATORS) <em>translators</em>: MessageTranslator[]) {<br>        for (<em>let</em> translator of <em>translators</em>) {<br>            this.map.set(translator.getKey(), translator.translate());<br>        }<br>    }</pre>\n<pre>    getMap(): <em>ReadonlyMap</em>&lt;<em>string</em>, <em>string</em>&gt; {<br>        return this.map;<br>    }<br>}</pre>\n<p>We used the following simulation for a message producer, which produces a message key every second randomly. In our case we had just kept 2 possible options <em>SessionExpiredMessage and IncorrectUserNameOrPasswordMessage</em> for brevity, however, in real scenarios, we can have multiple message keys based on the\u00a0domain.</p>\n<p><strong><em>MessageProducer</em></strong></p>\n<pre>import { interval, map, tap } from \"rxjs\";</pre>\n<pre><em>const</em> getRandomInt = (<em>min</em>: <em>number</em>, <em>max</em>: <em>number</em>) <em>=&gt;</em> {<br><em>min</em> = Math.ceil(<em>min</em>);<br><em>max</em> = Math.floor(<em>max</em>);<br>    return Math.floor(Math.random() * (<em>max</em> - <em>min</em>) + <em>min</em>); //The<br>maximum is exclusive and the minimum is inclusive<br>}</pre>\n<pre><em>const</em> messages = ['IncorrectUserNameOrPasswordMessage', 'SessionExpiredMessage'];</pre>\n<pre>/**<br>* Simple simulation for message producer transmitting message every second.<br>*/<br>export <em>const</em> produceMessage = () <em>=&gt;</em> {<br>    return interval(1000)<br>        .pipe(map(() <em>=&gt;</em> messages[getRandomInt(0, messages.length)]));<br>}</pre>\n<p>We will have to declare the providers for the message translators inside the module <strong><em>app.module.ts</em></strong></p>\n<pre>import { NgModule } from '@angular/core';<br>import { BrowserModule } from '@angular/platform-browser';<br>import { AppComponent } from './app.component';<br>import { IncorrectUserNameOrPasswordMessageTranslator } from './message-translators/incorrect-user-name-message-translator.service';<br>import { MESSAGE_TRANSLATORS } from './message-translators/message-translator';<br>import { SessionExpiredMessageTranslator } from './message-translators/session-expired-message-translator.service';</pre>\n<pre>@NgModule({<br>    declarations: [<br>        AppComponent<br>    ],<br>    imports: [<br>        BrowserModule<br>    ],<br>    providers: [<br>        { provide: MESSAGE_TRANSLATORS, useClass: IncorrectUserNameOrPasswordMessageTranslator, multi: true },<br>        { provide: MESSAGE_TRANSLATORS, useClass: SessionExpiredMessageTranslator, multi: true },<br>    ],<br>    bootstrap: [AppComponent]<br>})<br>export <em>class</em> AppModule { }</pre>\n<p>Finally here is a very simple template for rendering the message key and translated message: <strong><em>app.component.html</em></strong></p>\n<pre>&lt;div class=\"container\"&gt;<br>    &lt;h1&gt;Strategy Demo&lt;/h1&gt;<br>    &lt;div class=\"row\"&gt;<br>        &lt;div class=\"col-4\"&gt;<br>            Message Key<br>        &lt;/div&gt;<br>        &lt;div class=\"col-8\"&gt;<br>            &lt;p #key &gt;{{ messageKeyStream$ | async }}&lt;/p&gt;<br>        &lt;/div&gt;<br>        &lt;div class=\"col-4\"&gt;<br>            Translated Message<br>        &lt;/div&gt;<br>        &lt;div class=\"col-8\"&gt;<br>            {{ getTranslatedMessageFor(key.innerText) }}<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/div&gt;</pre>\n<p><strong><em>app.component.ts</em></strong></p>\n<pre>import { Component } from '@angular/core';<br>import { Observable, tap } from 'rxjs';<br>import { MessageTranslatorMap } from './message-translators/message-translator-map.service';<br>import { produceMessage } from './mock/message-producer.mock';</pre>\n<pre>@Component({<br>    selector: 'app-root',<br>    templateUrl: './app.component.html',<br>    styleUrls: ['./app.component.css']<br>})<br>export <em>class</em> AppComponent {<br>    messageKeyStream$: Observable&lt;<em>string</em>&gt;;</pre>\n<pre><em>    constructor</em>(private <em>messageTranslator</em>: MessageTranslatorMap) {<br>        /**<br>         * return a stream where each emitted item will serve as a key for the strategy.<br>         */<br>        this.messageKeyStream$ = produceMessage();<br>    }</pre>\n<pre>    getTranslatedMessageFor(<em>key</em>: <em>string</em>) {<br>        return this.messageTranslator.getMap().get(<em>key</em>);<br>    }<br>}</pre>\n<p>Hope you have liked the article and will find it useful for your projects.</p>\n<p>Connect with me on <a href=\"https://www.linkedin.com/in/praveen-kumar-788429192/\">LinkedIn</a>.</p>\n<p>Check out my developer <a href=\"https://pravnkr.github.io/dev-portfolio/\">Portfolio</a>.</p>\n<p>Go and check out my work on\u00a0<a href=\"https://github.com/pravnkr\">Github</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bd06065bad50\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["design-patterns","strategy-pattern","angular","angular-13","angular2"]}]}